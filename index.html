<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Openterface Ops GUI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .image-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .image-section.active {
            display: block;
        }
        
        .image-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .image-box {
            flex: 1;
            max-width: 500px;
            text-align: center;
        }
        
        .image-box h3 {
            margin-bottom: 10px;
            color: #666;
        }
        
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .chat-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .chat-messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #fafafa;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            max-width: 80%;
        }
        
        .message.user {
            background-color: #e3f2fd;
            margin-left: auto;
            text-align: right;
        }
        
        .message.assistant {
            background-color: #f1f8e9;
            margin-right: auto;
        }
        
        .chat-input {
            display: flex;
            gap: 10px;
            flex-direction: column;
        }

        #query-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            resize: none;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
            font-family: inherit;
        }
        
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .config-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .config-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .config-item {
            display: flex;
            flex-direction: column;
        }
        
        .config-item label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #666;
        }
        
        .config-item input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .config-actions {
            text-align: center;
        }
        
        .error {
            color: red;
            margin-top: 10px;
        }
        
        .loading {
            color: #666;
            font-style: italic;
        }
        
        .react-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .react-section.active {
            display: block;
        }
        
        .react-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .react-progress {
            flex: 1;
            margin-right: 20px;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 14px;
            color: #666;
        }
        
        .react-images {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .react-image-item {
            flex: 0 0 auto;
            text-align: center;
        }
        
        .react-image-item img {
            max-width: 200px;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .react-image-item span {
            display: block;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        .stop-btn {
            background-color: #f44336;
        }
        
        .stop-btn:hover {
            background-color: #d32f2f;
        }

        /* Approval Dialog Styles */
        .approval-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .approval-content {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-in-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .approval-content h3 {
            color: #f44336;
            margin-bottom: 20px;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .approval-details {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .approval-details p {
            margin: 8px 0;
            color: #856404;
            font-size: 14px;
        }

        .approval-details strong {
            color: #333;
            font-weight: 600;
        }

        .approval-image {
            margin-bottom: 20px;
            text-align: center;
            border: 2px solid #ffc107;
            border-radius: 4px;
            padding: 10px;
            background-color: #fff;
        }

        .approval-image img {
            max-width: 100%;
            border-radius: 4px;
        }

        .approval-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-approve,
        .btn-reject,
        .btn-approve-all {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-approve {
            background-color: #4CAF50;
            color: white;
        }

        .btn-approve:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }

        .btn-reject {
            background-color: #f44336;
            color: white;
        }

        .btn-reject:hover {
            background-color: #d32f2f;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
        }

        .btn-approve-all {
            background-color: #2196F3;
            color: white;
        }

        .btn-approve-all:hover {
            background-color: #1976D2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
        }

        @media (max-width: 768px) {
            .approval-content {
                padding: 20px;
                max-width: 95%;
            }

            .approval-actions {
                flex-direction: column;
            }

            .btn-approve,
            .btn-reject,
            .btn-approve-all {
                width: 100%;
            }
        }
        
        .final-reasoning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .final-reasoning strong {
            color: #856404;
            display: block;
            margin-bottom: 8px;
        }
        
        .final-reasoning p {
            margin: 0;
            color: #666;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .react-progress {
            background-color: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .react-progress strong {
            color: #1976D2;
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Openterface Ops GUI</h1>
        
        <!-- Configuration Section -->
        <div class="config-section">
            <h3>Model Configuration</h3>
            <div class="config-grid">
                <div class="config-item">
                    <label for="api-url">LLM API URL:</label>
                    <input type="text" id="api-url" placeholder="Enter LLM API URL" value="http://localhost:8001/v1/chat/completions">
                </div>
                <div class="config-item">
                    <label for="model">LLM Model:</label>
                    <input type="text" id="model" placeholder="Enter LLM Model Name" value="qwen3.5-27b">
                </div>
                <div class="config-item">
                    <label for="ui-model-api-url">UI-Model API URL:</label>
                    <input type="text" id="ui-model-api-url" placeholder="Enter UI-Model API URL" value="http://localhost:2345/v1/chat/completions">
                </div>
                <div class="config-item">
                    <label for="ui-model">UI-Model:</label>
                    <input type="text" id="ui-model" placeholder="Enter UI-Model Name" value="gui-owl-7b">
                </div>
                <div class="config-item">
                    <label for="react-max-iterations">Agent Max Iterations:</label>
                    <input type="number" id="react-max-iterations" placeholder="Enter max iterations" value="20" min="1">
                </div>
                <div class="config-item">
                    <label for="scene-type">Scene Type:</label>
                    <select id="scene-type">
                        <option value="auto" selected>Auto (VLM Detection)</option>
                        <option value="general">General (Mixed/Unknown)</option>
                        <option value="bios">BIOS/UEFI</option>
                        <option value="windows">Windows</option>
                        <option value="linux">Linux</option>
                        <option value="os_installation">OS Installation</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 15px; background-color: #f5f5f5; border-radius: 4px;">
                <h4>API Key Configuration</h4>
                <p>Please set the following environment variables before running the application:</p>
                <ul style="list-style-type: disc; margin-left: 20px;">
                    <li><strong>LLM_API_KEY</strong>: API key for the main language model (default: "EMPTY")</li>
                    <li><strong>UI_API_KEY</strong>: API key for the UI-Model (default: "EMPTY")</li>
                </ul>
                <p>Example for Windows:</p>
                <pre style="background-color: #e0e0e0; padding: 10px; border-radius: 4px; overflow-x: auto;">
set LLM_API_KEY=your_llm_api_key
set UI_API_KEY=your_ui_api_key</pre>
                <p>Example for Linux/Mac:</p>
                <pre style="background-color: #e0e0e0; padding: 10px; border-radius: 4px; overflow-x: auto;">
export LLM_API_KEY=your_llm_api_key
export UI_API_KEY=your_ui_api_key</pre>
            </div>
            <div class="config-actions">
                <button id="init-btn">Initialize Session</button>
            </div>
        </div>
        
        <div class="image-section">
            <div class="image-container">
                <div class="image-box">
                    <h3>Present Screen</h3>
                    <img id="original-image" src="" alt="Present Screen">
                </div>
                <div class="image-box">
                    <h3>Proposed Action</h3>
                    <img id="processed-image" src="" alt="Proposed Action">
                </div>
            </div>
        </div>
        
        <!-- ReAct Agent Section -->
        <div class="react-section" id="react-section">
            <h3>ReAct Agent Progress</h3>
            <div class="react-status">
                <div class="react-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-text" id="progress-text">Initializing...</div>
                </div>
                <button id="stop-react-btn" class="stop-btn">Stop Agent</button>
            </div>
            <div class="react-images" id="react-images">
            </div>
        </div>

        <!-- Approval Dialog -->
        <div id="approval-dialog" class="approval-dialog" style="display: none;">
            <div class="approval-content">
                <h3>⚠️ Dangerous Operation Requires Approval</h3>
                <div class="approval-details">
                    <p><strong>Iteration:</strong> <span id="approval-iteration">-</span></p>
                    <p><strong>Action:</strong> <span id="approval-action">-</span></p>
                    <p><strong>Element:</strong> <span id="approval-element">-</span></p>
                    <p id="approval-key-content-row" style="display: none;"><strong>Key Content:</strong> <span id="approval-key-content">-</span></p>
                    <p><strong>Reasoning:</strong> <span id="approval-reasoning">-</span></p>
                    <p><strong>Risk Level:</strong> <span id="approval-risk">-</span></p>
                </div>
                <div class="approval-image" id="approval-image-container" style="display: none;">
                    <img id="approval-image" src="" alt="Current screen">
                </div>
                <div class="approval-actions">
                    <button class="btn-approve" onclick="approveAction()">Approve</button>
                    <button class="btn-reject" onclick="rejectAction()">Reject</button>
                    <button class="btn-approve-all" onclick="approveAllActions()">Approve All Future Actions</button>
                </div>
            </div>
        </div>

        <div class="chat-section">
            <div class="chat-messages" id="chat-messages">
                <div class="message assistant">
                    Welcome to Openterface Ops API! Please enter your query.
                </div>
            </div>
            <div class="chat-input">
                <textarea id="query-input" placeholder="Enter your query..."></textarea>
                <button id="send-btn">Send</button>
            </div>
            <div id="error-message" class="error"></div>
        </div>
    </div>
    
    <script>
        // API Configuration
        const API_BASE_URL = 'http://localhost:9000';
        let sessionId = '';
        let currentTaskId = null;
        let currentEventSource = null;
        let isStopping = false;
        
        // Debug function to log EventSource state
        function logEventSourceState(context) {
            console.log(`[${context}] EventSource state:`, {
                exists: currentEventSource !== null,
                readyState: currentEventSource ? currentEventSource.readyState : 'N/A',
                url: currentEventSource ? currentEventSource.url : 'N/A'
            });
        }
        
        // Extract final_reasoning from text
        function extractFinalReasoning(text) {
            const pattern = /<final_reasoning>([\s\S]*?)<\/final_reasoning>/;
            const match = text.match(pattern);
            return match ? match[1].trim() : null;
        }
        
        // Initialization
        async function init() {
            try {
                // Get configuration from input fields
                const apiUrl = document.getElementById('api-url').value;
                const model = document.getElementById('model').value;
                const uiModelApiUrl = document.getElementById('ui-model-api-url').value;
                const uiModel = document.getElementById('ui-model').value;
                
                // Create session with configuration
                const sessionResponse = await fetch(`${API_BASE_URL}/create-session`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        language: 'en',
                        api_url: apiUrl,
                        model: model,
                        ui_model_api_url: uiModelApiUrl,
                        ui_model: uiModel
                    })
                });
                
                const sessionData = await sessionResponse.json();
                if (sessionData.success) {
                    sessionId = sessionData.session_id;
                    console.log('Session created successfully:', sessionId);
                    
                    // Clear previous messages except welcome message
                    const chatMessages = document.getElementById('chat-messages');
                    chatMessages.innerHTML = '<div class="message assistant">Welcome to Openterface Ops API! Please enter your query.</div>';
                    
                    // Display available commands
                    const helpMessage = `Available commands:<br>
/quit, /exit, /q - Exit the program<br>
/clear, /cls - Clear chat history<br>
/help - Show help information<br>
/info - Show API status information<br>
/lang [en|zh] - Switch language<br>
/scene [auto|general|bios|windows|linux|os_installation] - Switch scene type<br>
/multiturn - Enter multi-turn conversation mode<br>
/single - Exit multi-turn conversation mode<br>
/load docs - Load documents and build index<br>
/unload docs - Close document index<br>
/image - Get latest image<br>
/react [task] - Start ReAct agent mode<br>
/stop-react - Stop running ReAct agent`;
                    addMessage(helpMessage, 'assistant');
                    
                    // Clear images
                    document.getElementById('original-image').src = '';
                    document.getElementById('processed-image').src = '';
                    document.querySelector('.image-section').classList.remove('active');

                    // Clear error message
                    document.getElementById('error-message').textContent = '';
                } else {
                    throw new Error('Failed to create session');
                }
            } catch (error) {
                console.error('Initialization failed:', error);
                document.getElementById('error-message').textContent = 'Initialization failed: ' + error.message;
            }
        }
        
        // Get images
        async function fetchImages() {
            try {
                // Call /get-image endpoint to get server image
                const response = await fetch(`${API_BASE_URL}/get-image`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });
                
                const data = await response.json();
                if (data.success && data.image) {
                    // Only display original image
                    document.getElementById('original-image').src = `data:image/jpeg;base64,${data.image}`;
                    document.querySelector('.image-section').classList.add('active');
                }
            } catch (error) {
                console.error('Failed to get images:', error);
                // Ignore image fetch failure, continue running
            }
        }
        
        // Send query
        async function sendQuery() {
            const queryInput = document.getElementById('query-input');
            let query = queryInput.value.trim();
            if (!query) return;
            
            // Clear error message
            document.getElementById('error-message').textContent = '';
            
            // Handle special commands
            // Exit program command (handled by frontend)
            if (['/quit', '/exit', '/q'].includes(query.toLowerCase())) {
                addMessage(query, 'user');
                addMessage('Exit command received. You can close the browser window directly.', 'assistant');
                queryInput.value = '';
                return;
            }
            
            // Clear history command
            if (['/clear', '/cls'].includes(query.toLowerCase())) {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/clear-history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        addMessage('Chat history cleared', 'assistant');

                        // Clear images
                        document.getElementById('original-image').src = '';
                        document.getElementById('processed-image').src = '';
                        document.querySelector('.image-section').classList.remove('active');
                    } else {
                        throw new Error('Failed to clear history');
                    }
                } catch (error) {
                    console.error('Failed to clear history:', error);
                    document.getElementById('error-message').textContent = 'Failed to clear history: ' + error.message;
                }
                return;
            }
            
            // Help command (handled by frontend)
            if (query.toLowerCase() === '/help') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                const helpMessage = `Available commands:<br>
/quit, /exit, /q - Exit the program<br>
/clear, /cls - Clear chat history<br>
/help - Show help information<br>
/info - Show API status information<br>
/lang [en|zh] - Switch language<br>
/scene [auto|general|bios|windows|linux|os_installation] - Switch scene type<br>
/multiturn - Enter multi-turn conversation mode<br>
/single - Exit multi-turn conversation mode<br>
/load docs - Load documents and build index<br>
/unload docs - Close document index<br>
/image - Get latest image<br>
/react [task] - Start ReAct agent mode<br>
/stop-react - Stop running ReAct agent`;
                
                addMessage(helpMessage, 'assistant');
                return;
            }
            
            // Show API info command
            if (query.toLowerCase() === '/info') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/status/${sessionId}`);
                    const data = await response.json();
                    if (data.success) {
                        const infoMessage = `API Status Information:<br>
Main API Status: ${data.api_status}<br>
UI-Model API Status: ${data.ui_model_status}`;
                        addMessage(infoMessage, 'assistant');
                    } else {
                        throw new Error('Failed to get API status');
                    }
                } catch (error) {
                    console.error('Failed to get API status:', error);
                    document.getElementById('error-message').textContent = 'Failed to get API status: ' + error.message;
                }
                return;
            }
            
            // Language switch command
            if (query.toLowerCase().startsWith('/lang')) {
                addMessage(query, 'user');
                queryInput.value = '';
                
                const parts = query.split(/\s+/);
                if (parts.length === 1) {
                    // Show current language (frontend can't get it directly, need to call API)
                    addMessage('Please use /lang en or /lang zh to switch languages', 'assistant');
                } else if (parts.length === 2) {
                    const langCode = parts[1].toLowerCase();
                    if (langCode === 'en' || langCode === 'zh') {
                        try {
                            const response = await fetch(`${API_BASE_URL}/switch-lang`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    session_id: sessionId,
                                    lang_code: langCode
                                })
                            });
                            
                            const data = await response.json();
                            if (data.success) {
                                addMessage(`Language switched to ${langCode}`, 'assistant');
                            } else {
                                throw new Error('Failed to switch language');
                            }
                        } catch (error) {
                            console.error('Failed to switch language:', error);
                            document.getElementById('error-message').textContent = 'Failed to switch language: ' + error.message;
                        }
                    } else {
                        addMessage('Invalid language code. Please use en or zh', 'assistant');
                    }
                }
                return;
            }
            
            // Scene switch command
            if (query.toLowerCase().startsWith('/scene')) {
                addMessage(query, 'user');
                queryInput.value = '';
                
                const parts = query.split(/\s+/);
                if (parts.length === 1) {
                    addMessage('Please use /scene [auto|general|bios|windows|linux|os_installation] to switch scene type', 'assistant');
                } else if (parts.length === 2) {
                    const sceneType = parts[1].toLowerCase();
                    const validScenes = ['auto', 'general', 'bios', 'windows', 'linux', 'os_installation'];
                    if (validScenes.includes(sceneType)) {
                        try {
                            const response = await fetch(`${API_BASE_URL}/switch-scene`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    session_id: sessionId,
                                    scene_type: sceneType
                                })
                            });
                            
                            const data = await response.json();
                            if (data.success) {
                                addMessage(`Scene switched to ${sceneType}`, 'assistant');
                                document.getElementById('scene-type').value = sceneType;
                            } else {
                                throw new Error(data.message || 'Failed to switch scene');
                            }
                        } catch (error) {
                            console.error('Failed to switch scene:', error);
                            document.getElementById('error-message').textContent = 'Failed to switch scene: ' + error.message;
                        }
                    } else {
                        addMessage(`Invalid scene type. Valid options: ${validScenes.join(', ')}`, 'assistant');
                    }
                }
                return;
            }
            
            // Multi-turn conversation mode command
            if (query.toLowerCase() === '/multiturn') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/toggle-multiturn`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            mode: true
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        addMessage('Entered multi-turn conversation mode', 'assistant');
                    } else {
                        throw new Error('Failed to switch to multi-turn conversation mode');
                    }
                } catch (error) {
                    console.error('Failed to switch to multi-turn conversation mode:', error);
                    document.getElementById('error-message').textContent = 'Failed to switch to multi-turn conversation mode: ' + error.message;
                }
                return;
            }
            
            // Single-turn conversation mode command
            if (query.toLowerCase() === '/single') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/toggle-multiturn`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            mode: false
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        addMessage('Exited multi-turn conversation mode, entered single-turn conversation mode', 'assistant');
                    } else {
                        throw new Error('Failed to switch to single-turn conversation mode');
                    }
                } catch (error) {
                    console.error('Failed to switch to single-turn conversation mode:', error);
                    document.getElementById('error-message').textContent = 'Failed to switch to single-turn conversation mode: ' + error.message;
                }
                return;
            }
            
            // Load documents and build index command
            if (query.toLowerCase() === '/load docs') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/build-index`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        addMessage('Document index built successfully', 'assistant');
                    } else {
                        addMessage(`Failed to build document index: ${data.message}`, 'assistant');
                    }
                } catch (error) {
                    console.error('Failed to build document index:', error);
                    document.getElementById('error-message').textContent = 'Failed to build document index: ' + error.message;
                }
                return;
            }
            
            // Unload document index command
            if (query.toLowerCase() === '/unload docs') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/toggle-rag`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        addMessage(data.rag_enabled ? 'Document index enabled' : 'Document index disabled', 'assistant');
                    } else {
                        addMessage(`Failed to unload document index: ${data.message}`, 'assistant');
                    }
                } catch (error) {
                    console.error('Failed to unload document index:', error);
                    document.getElementById('error-message').textContent = 'Failed to unload document index: ' + error.message;
                }
                return;
            }
            
            // Get image command
            if (query.toLowerCase() === '/image') {
                // Add user message
                addMessage(query, 'user');

                // Clear input box
                queryInput.value = '';

                // Clear previous images
                document.getElementById('original-image').src = '';
                document.getElementById('processed-image').src = '';

                // Call get image function
                try {
                    await fetchImages();
                    // Add system message
                    addMessage('Latest image obtained. Please enter your question.', 'assistant');
                } catch (error) {
                    console.error('Failed to get image:', error);
                    document.getElementById('error-message').textContent = 'Failed to get image: ' + error.message;
                }
                return;
            }
            
            // ReAct agent command
            if (query.toLowerCase().startsWith('/react')) {
                addMessage(query, 'user');
                queryInput.value = '';

                // Clear images
                document.getElementById('original-image').src = '';
                document.getElementById('processed-image').src = '';
                document.querySelector('.image-section').classList.remove('active');

                let task = '';

                const commandPart = query.substring(6).trim();

                if (!commandPart) {
                    addMessage('Usage: /react [task] <br>Example: /react "Open Notepad and type Hello" <br>Note: Max iterations is set in the configuration area above', 'assistant');
                    return;
                }

                task = commandPart;

                if (!task) {
                    addMessage('Usage: /react [task] <br>Example: /react "Open Notepad and type Hello" <br>Note: Max iterations is set in the configuration area above', 'assistant');
                    return;
                }

                // Get max iterations from configuration
                const maxIterations = parseInt(document.getElementById('react-max-iterations').value) || 20;

                addMessage(`Starting ReAct agent with task: "${task}" (max iterations: ${maxIterations})`, 'assistant');
                
                // Show ReAct section
                document.getElementById('react-section').classList.add('active');
                document.getElementById('progress-fill').style.width = '0%';
                document.getElementById('progress-text').textContent = 'Starting ReAct agent...';
                document.getElementById('react-images').innerHTML = '';
                
                // Disable input and button
                queryInput.disabled = true;
                document.getElementById('send-btn').disabled = true;
                
                try {
                    // Create task
                    const createResponse = await fetch(`${API_BASE_URL}/react-task`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            task: task,
                            max_iterations: maxIterations,
                            approval_policy: 'manual'
                        })
                    });
                    
                    const createData = await createResponse.json();
                    
                    if (!createData.success) {
                        throw new Error('Failed to create task');
                    }
                    
                    currentTaskId = createData.task_id;
                    console.log('Task created:', currentTaskId);
                    
                    // Close existing event source if any
                    if (currentEventSource) {
                        console.log('Closing existing EventSource before creating new one');
                        currentEventSource.close();
                        currentEventSource = null;
                    }
                    
                    // Connect to SSE stream
                    currentEventSource = new EventSource(`${API_BASE_URL}/react-stream/${currentTaskId}`);
                    console.log('EventSource created, readyState:', currentEventSource.readyState);
                    
                    currentEventSource.onmessage = function(event) {
                        try {
                            console.log('SSE event received:', event.data);
                            const data = JSON.parse(event.data);
                            console.log('Parsed SSE data:', data);
                            console.log('Event type:', data.event);
                            console.log('Event type type:', typeof data.event);
                            console.log('Event type value:', JSON.stringify(data.event));
                            
                            if (data.event === 'progress') {
                                console.log('Entering progress branch');
                                const progressData = data.data;
                                
                                // Update progress bar
                                const progressPercent = (progressData.iteration / progressData.max_iterations) * 100;
                                document.getElementById('progress-fill').style.width = `${progressPercent}%`;
                                
                                // Update progress text - only show action and reasoning
                                let statusText = `Iteration ${progressData.iteration}/${progressData.max_iterations}`;
                                if (progressData.action) {
                                    if (progressData.action === 'Keyboard' && progressData.key_content) {
                                        statusText += `\nAction: ${progressData.action} (Key: ${progressData.key_content})`;
                                    } else if (progressData.element) {
                                        statusText += `\nAction: ${progressData.action} on ${progressData.element}`;
                                    } else {
                                        statusText += `\nAction: ${progressData.action}`;
                                    }
                                }
                                if (progressData.reasoning) {
                                    statusText += `\nReasoning: ${progressData.reasoning}`;
                                }
                                document.getElementById('progress-text').textContent = statusText;
                                
                                // Add progress message to chat - only show action and reasoning
                                const progressMessage = `
                                    <div class="react-progress">
                                        <strong>Iteration ${progressData.iteration}/${progressData.max_iterations}</strong><br>
                                        ${progressData.action ? `Action: ${progressData.action}` : ''}${progressData.action === 'Keyboard' && progressData.key_content ? ` (Key: ${progressData.key_content})` : ''}<br>
                                        ${progressData.element && progressData.action !== 'Keyboard' ? `Element: ${progressData.element}` : ''}<br>
                                        ${progressData.reasoning ? `Reasoning: ${progressData.reasoning}` : ''}
                                    </div>
                                `;
                                addMessage(progressMessage, 'assistant');
                                
                            } else if (data.event === 'approval_required') {
                                console.log('Entering approval_required branch');
                                const approvalData = data.data;
                                console.log('Approval required:', approvalData);
                                
                                // Show approval dialog
                                showApprovalDialog(approvalData);
                                
                            } else if (data.event === 'completed') {
                                console.log('Entering completed branch');
                                const completedData = data.data;
                                
                                // Extract final_reasoning if present
                                const finalReasoning = extractFinalReasoning(completedData.message);
                                
                                // Remove final_reasoning tag from message to avoid duplication
                                const cleanMessage = completedData.message.replace(/<final_reasoning>[\s\S]*?<\/final_reasoning>/, '').trim();
                                
                                let completionMessage = '';
                                let progressText = '';
                                
                                if (completedData.final_status === 'max_iterations') {
                                    completionMessage = `ReAct agent reached maximum iterations (${completedData.iterations_completed}/${completedData.iterations_completed})<br>${cleanMessage}`;
                                    progressText = `Max iterations reached`;
                                } else if (completedData.final_status === 'completed') {
                                    if (finalReasoning) {
                                        // Display final reasoning in a styled box
                                        const reasoningHtml = `
                                            <div class="final-reasoning">
                                                <strong>Final Reasoning:</strong>
                                                <p>${finalReasoning}</p>
                                            </div>
                                        `;
                                        completionMessage = `ReAct agent completed successfully in ${completedData.iterations_completed} iterations<br>${cleanMessage}<br>${reasoningHtml}`;
                                    } else {
                                        completionMessage = `ReAct agent completed successfully in ${completedData.iterations_completed} iterations<br>${cleanMessage}`;
                                    }
                                    progressText = `Completed: ${cleanMessage}`;
                                } else {
                                    completionMessage = `ReAct agent finished with status: ${completedData.final_status}<br>${cleanMessage}`;
                                    progressText = `Finished: ${completedData.final_status}`;
                                }
                                
                                addMessage(completionMessage, 'assistant');
                                
                                document.getElementById('progress-fill').style.width = '100%';
                                document.getElementById('progress-text').textContent = progressText;
                                
                                // Display iteration images
                                if (completedData.images && completedData.images.length > 0) {
                                    const reactImages = document.getElementById('react-images');
                                    completedData.images.forEach((imgBase64, index) => {
                                        const imageItem = document.createElement('div');
                                        imageItem.className = 'react-image-item';
                                        imageItem.innerHTML = `
                                            <img src="data:image/jpeg;base64,${imgBase64}" alt="Iteration ${index + 1}">
                                            <span>Iteration ${index + 1}</span>
                                        `;
                                        reactImages.appendChild(imageItem);
                                    });
                                }
                                
                                // Close event source
                                currentEventSource.close();
                                currentEventSource = null;
                                
                                // Reset task ID and stopping flag
                                currentTaskId = null;
                                isStopping = false;
                                
                                // Re-enable input and button
                                queryInput.disabled = false;
                                document.getElementById('send-btn').disabled = false;
                                
                            } else if (data.event === 'stopped') {
                                console.log('Entering stopped branch');
                                console.log('Processing stopped event:', data);
                                const stoppedData = data.data;
                                
                                // Note: The stop signal message was already added when the user clicked the Stop button
                                // We don't need to add it again here to avoid duplicate messages
                                
                                const message = `ReAct agent stopped by user at iteration ${stoppedData.iterations_completed}`;
                                console.log('About to call addMessage with:', message);
                                const messageElement = addMessage(message, 'assistant');
                                console.log('addMessage returned:', messageElement);
                                
                                document.getElementById('progress-text').textContent = 'Stopped by user';
                                
                                // Close event source
                                currentEventSource.close();
                                currentEventSource = null;
                                
                                // Reset task ID and stopping flag
                                currentTaskId = null;
                                isStopping = false;
                                
                                // Re-enable input and button
                                queryInput.disabled = false;
                                document.getElementById('send-btn').disabled = false;
                                console.log('Stopped event processed, UI reset');
                                
                            } else if (data.event === 'error') {
                                console.log('Entering error branch');
                                const errorData = data.data;
                                
                                addMessage(`ReAct agent error: ${errorData.error}`, 'assistant');
                                document.getElementById('progress-text').textContent = `Error: ${errorData.error}`;
                                
                                // Close event source
                                currentEventSource.close();
                                currentEventSource = null;
                                
                                // Reset task ID and stopping flag
                                currentTaskId = null;
                                isStopping = false;
                                
                                // Re-enable input and button
                                queryInput.disabled = false;
                                document.getElementById('send-btn').disabled = false;
                            } else {
                                console.log('Unknown event type:', data.event);
                            }
                        } catch (e) {
                            console.error('Error parsing SSE event:', e);
                        }
                    };
                    
                    currentEventSource.onerror = function(error) {
                        console.error('SSE error:', error);
                        console.error('EventSource readyState:', currentEventSource.readyState);
                        currentEventSource.close();
                        currentEventSource = null;
                        
                        // Reset task ID and stopping flag
                        currentTaskId = null;
                        isStopping = false;
                        
                        // Re-enable input and button
                        queryInput.disabled = false;
                        document.getElementById('send-btn').disabled = false;
                        
                        addMessage('Connection to ReAct agent lost', 'assistant');
                    };
                    
                } catch (error) {
                    console.error('Failed to run ReAct agent:', error);
                    document.getElementById('error-message').textContent = 'Failed to run ReAct agent: ' + error.message;
                    document.getElementById('progress-text').textContent = 'Error: ' + error.message;
                    
                    // Close event source if open
                    if (currentEventSource) {
                        currentEventSource.close();
                        currentEventSource = null;
                    }
                    
                    // Reset task ID and stopping flag
                    currentTaskId = null;
                    isStopping = false;
                    
                    // Re-enable input and button
                    queryInput.disabled = false;
                    document.getElementById('send-btn').disabled = false;
                }
                return;
            }
            
            // Stop ReAct agent command
            if (query.toLowerCase() === '/stop-react') {
                addMessage(query, 'user');
                queryInput.value = '';
                
                if (!currentTaskId) {
                    addMessage('No ReAct task is currently running', 'assistant');
                    return;
                }
                
                if (isStopping) {
                    addMessage('Stop request already in progress', 'assistant');
                    return;
                }
                
                isStopping = true;
                document.getElementById('progress-text').textContent = 'Stopping...';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/stop-react-task`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            task_id: currentTaskId
                        })
                    });
                    
                    const data = await response.json();
                    logEventSourceState('After stop response received');
                    if (data.success) {
                        // Check if task has already stopped (received stopped event)
                        if (!currentTaskId) {
                            // Task already stopped by stopped event, don't show duplicate message
                            console.log('Task already stopped, skipping duplicate message');
                            return;
                        }
                        addMessage('ReAct agent stop signal sent, waiting for task to stop...', 'assistant');
                        // Don't close event source here - wait for 'stopped' event from server
                    } else {
                        addMessage(data.message, 'assistant');
                        isStopping = false;
                        document.getElementById('progress-text').textContent = 'Stop failed';
                    }
                } catch (error) {
                    console.error('Failed to stop ReAct agent:', error);
                    document.getElementById('error-message').textContent = 'Failed to stop ReAct agent: ' + error.message;
                    isStopping = false;
                    document.getElementById('progress-text').textContent = 'Stop failed';
                }
                return;
            }
            
            // Add user message
            addMessage(query, 'user');
            
            // Clear input box
            queryInput.value = '';
            
            // Clear current processed image
            document.getElementById('processed-image').src = '';
            document.querySelector('.image-section').classList.remove('active');
            
            // Get send button element
            const sendBtn = document.getElementById('send-btn');
            
            // Disable input and button, add loading message
            queryInput.disabled = true;
            sendBtn.disabled = true;
            const loadingMessage = addMessage('Thinking...', 'assistant');
            
            try {
                // Send request, do not re-fetch image, use previously obtained image
                const response = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        prompt: query
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Remove loading message
                    loadingMessage.remove();
                    
                    // Extract final_reasoning if present
                    const finalReasoning = extractFinalReasoning(data.response);
                    
                    if (finalReasoning) {
                        // Display final reasoning in a styled box
                        const reasoningHtml = `
                            <div class="final-reasoning">
                                <strong>Final Reasoning:</strong>
                                <p>${finalReasoning}</p>
                            </div>
                        `;
                        // Remove the final_reasoning tag from the response
                        const cleanResponse = data.response.replace(/<final_reasoning>[\s\S]*?<\/final_reasoning>/, '').trim();
                        addMessage(`${cleanResponse}<br>${reasoningHtml}`, 'assistant');
                    } else {
                        // Add assistant message
                        addMessage(data.response, 'assistant');
                    }
                    
                    // If there is an image, update processed image
                    if (data.image) {
                        document.getElementById('processed-image').src = `data:image/jpeg;base64,${data.image}`;
                        document.querySelector('.image-section').classList.add('active');
                    }
                } else {
                    throw new Error('API response failed');
                }
            } catch (error) {
                console.error('Failed to send query:', error);
                document.getElementById('error-message').textContent = 'Failed to send query: ' + error.message;
                // Remove loading message
                loadingMessage.remove();
            } finally {
                // Re-enable input and button
                queryInput.disabled = false;
                sendBtn.disabled = false;
            }
        }
        
        // Add message to chat history
        function addMessage(text, sender) {
            console.log('addMessage called with:', {text: text.substring(0, 50), sender});
            const chatMessages = document.getElementById('chat-messages');
            console.log('chat-messages element:', chatMessages);
            if (!chatMessages) {
                console.error('chat-messages element not found!');
                return null;
            }
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            messageDiv.innerHTML = text.replace(/\n/g, '<br>');
            chatMessages.appendChild(messageDiv);
            console.log('Message added to DOM');
            
            // Force scroll to bottom
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                console.log('Forced scroll to bottom, scrollHeight:', chatMessages.scrollHeight);
            }, 0);
            
            // Return the created message element
            return messageDiv;
        }

        // Approval dialog functions
        function showApprovalDialog(approvalData) {
            document.getElementById('approval-iteration').textContent = approvalData.iteration;
            document.getElementById('approval-action').textContent = approvalData.action;
            document.getElementById('approval-element').textContent = approvalData.element;
            document.getElementById('approval-reasoning').textContent = approvalData.reasoning || '无';

            const keyContentRow = document.getElementById('approval-key-content-row');
            const keyContentSpan = document.getElementById('approval-key-content');
            if (approvalData.key_content && approvalData.key_content.trim() !== '') {
                keyContentRow.style.display = 'block';
                keyContentSpan.textContent = approvalData.key_content;
            } else {
                keyContentRow.style.display = 'none';
            }

            const riskSpan = document.getElementById('approval-risk');
            if (approvalData.is_dangerous) {
                riskSpan.textContent = '🔴 High Risk';
                riskSpan.style.color = '#f44336';
            } else {
                riskSpan.textContent = '🟡 Medium Risk';
                riskSpan.style.color = '#ff9800';
            }

            if (approvalData.image) {
                document.getElementById('approval-image').src = `data:image/jpeg;base64,${approvalData.image}`;
                document.getElementById('approval-image-container').style.display = 'block';
            } else {
                document.getElementById('approval-image-container').style.display = 'none';
            }

            document.getElementById('approval-dialog').style.display = 'flex';
        }

        async function approveAction() {
            if (!currentTaskId) {
                console.error('No task ID available');
                return;
            }

            // Close dialog immediately
            closeApprovalDialog();

            try {
                const response = await fetch(`${API_BASE_URL}/approve-action/${currentTaskId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });

                const data = await response.json();
                if (data.success) {
                    addMessage(`✅ Action approved (iteration ${data.iteration}), task continues`, 'assistant');
                } else {
                    addMessage(`❌ Approval failed: ${data.message}`, 'assistant');
                }
            } catch (error) {
                console.error('Failed to approve action:', error);
                addMessage(`❌ Approval failed: ${error.message}`, 'assistant');
            }
        }

        async function rejectAction() {
            const reason = prompt('Enter rejection reason (optional):', 'User rejected');

            if (!currentTaskId) {
                console.error('No task ID available');
                return;
            }

            // Close dialog immediately
            closeApprovalDialog();

            try {
                const response = await fetch(`${API_BASE_URL}/reject-action/${currentTaskId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reason: reason || 'User rejected' })
                });

                const data = await response.json();
                if (data.success) {
                    addMessage(`🚫 Action rejected (iteration ${data.iteration}), task stopped`, 'assistant');
                    document.getElementById('progress-text').textContent = 'Stopped by user';

                    document.getElementById('query-input').disabled = false;
                    document.getElementById('send-btn').disabled = false;
                } else {
                    addMessage(`❌ Rejection failed: ${data.message}`, 'assistant');
                }
            } catch (error) {
                console.error('Failed to reject action:', error);
                addMessage(`❌ Rejection failed: ${error.message}`, 'assistant');
            }
        }

        async function approveAllActions() {
            if (!currentTaskId) {
                console.error('No task ID available');
                return;
            }

            if (!confirm('Are you sure you want to approve all future actions? This will switch to auto-approval mode.')) {
                return;
            }

            // Close dialog immediately
            closeApprovalDialog();

            try {
                const response = await fetch(`${API_BASE_URL}/set-approval-policy/${currentTaskId}?policy=auto`, {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    addMessage(`✅ Switched to auto-approval mode, future actions will be executed automatically`, 'assistant');
                } else {
                    addMessage(`❌ Switch failed: ${data.message}`, 'assistant');
                }
            } catch (error) {
                console.error('Failed to approve all actions:', error);
                addMessage(`❌ Switch failed: ${error.message}`, 'assistant');
            }
        }

        function closeApprovalDialog() {
            document.getElementById('approval-dialog').style.display = 'none';
        }
        
        // Event listeners
        document.getElementById('send-btn').addEventListener('click', sendQuery);
        
        document.getElementById('init-btn').addEventListener('click', init);
        
        document.getElementById('stop-react-btn').addEventListener('click', async () => {
            if (!currentTaskId) {
                addMessage('No ReAct task is currently running', 'assistant');
                return;
            }
            
            if (isStopping) {
                addMessage('Stop request already in progress', 'assistant');
                return;
            }
            
            isStopping = true;
            document.getElementById('progress-text').textContent = 'Stopping...';
            logEventSourceState('Before sending stop request');
            
            // Add stop signal message immediately before sending the request
            addMessage('ReAct agent stop signal sent, waiting for task to stop...', 'assistant');
            
            try {
                const response = await fetch(`${API_BASE_URL}/stop-react-task`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        task_id: currentTaskId
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Don't close event source here - wait for 'stopped' event from server
                } else {
                    addMessage(data.message, 'assistant');
                    isStopping = false;
                    document.getElementById('progress-text').textContent = 'Stop failed';
                }
            } catch (error) {
                console.error('Failed to stop ReAct agent:', error);
                document.getElementById('error-message').textContent = 'Failed to stop ReAct agent: ' + error.message;
                isStopping = false;
                document.getElementById('progress-text').textContent = 'Stop failed';
            }
        });
        
        document.getElementById('query-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendQuery();
            }
        });
        
        // Initialize application
        init();
    </script>
</body>
</html>